import ArgumentParser
import Foundation
import Sake
import SwiftShell

@CommandGroup
struct ReleaseCommands {
    private struct BuildTarget {
        enum Arch {
            case x86
            case arm
        }
        enum OS {
            case macos
            case linux
        }

        let arch: Arch
        let os: OS

        var triple: String {
            switch (arch, os) {
                case (.x86, .macos): "x86_64-apple-macosx"
                case (.arm, .macos): "arm64-apple-macosx"
                case (.x86, .linux): "x86_64-unknown-linux-gnu"
                case (.arm, .linux): "aarch64-unknown-linux-gnu"
            }
        }
    }

    private enum Constants {
        static let buildArtifactsDirectory = ".build/artifacts"
        static let swiftVersion = "6.0"
        static let buildTargets: [BuildTarget] = [
            .init(arch: .arm, os: .macos),
            .init(arch: .x86, os: .macos),
            .init(arch: .x86, os: .linux),
            .init(arch: .arm, os: .linux),
        ]
        static let executableName = "progressline"
    }

    private struct ReleaseArguments: ParsableArguments {
        @Argument(help: "Version number")
        var version: String

        func validate() throws {
            guard version.range(of: #"^\d+\.\d+\.\d+$"#, options: .regularExpression) != nil else {
                throw ValidationError("Invalid version number. Should be in the format 'x.y.z'")
            }
        }
    }

    static var bumpVersion: Command {
        Command(
            description: "Bump version",
            skipIf: { context in
                let arguments = try ReleaseArguments.parse(context.arguments)
                try arguments.validate()

                let version = arguments.version
                let versionFilePath = "Sources/Version.swift"
                let currentVersion = try String(contentsOfFile: versionFilePath)
                    .split(separator: "\"")[1]
                if currentVersion == version {
                    print("Version is already \(version). Skipping...")
                    return true
                } else {
                    return false
                }
            },
            run: { context in
                let arguments = try ReleaseArguments.parse(context.arguments)
                try arguments.validate()

                let version = arguments.version
                let versionFilePath = "Sources/Version.swift"
                let versionFileContent = """
                // This file is autogenerated. Do not edit.
                let progressLineVersion = "\(version)"

                """
                try versionFileContent.write(toFile: versionFilePath, atomically: true, encoding: .utf8)

                try runAndPrint("git", "add", versionFilePath)
                try runAndPrint("git", "commit", "-m", "chore(release): Bump version to \(version)")
                print("Version bumped to \(version)")
            }
        )
    }

    static var buildReleaseArtifacts: Command {
        Command(
            description: "Build release artifacts",
            skipIf: { context in
                let arguments = try ReleaseArguments.parse(context.arguments)
                try arguments.validate()
                let version = arguments.version

                let targetsWithExistingArtifacts = Constants.buildTargets.filter { target in
                    let archivePath = executableArchivePath(triple: target.triple, version: version)
                    return FileManager.default.fileExists(atPath: archivePath)
                }
                if targetsWithExistingArtifacts.count == Constants.buildTargets.count {
                    print("Release artifacts already exist. Skipping...")
                    return true
                } else {
                    context.storage["existing-artifacts-triples"] = targetsWithExistingArtifacts.map(\.triple)
                    return false
                }
            },
            run: { context in
                let arguments = try ReleaseArguments.parse(context.arguments)
                try arguments.validate()
                let version = arguments.version

                try FileManager.default.createDirectory(
                    atPath: Constants.buildArtifactsDirectory,
                    withIntermediateDirectories: true,
                    attributes: nil
                )
                let existingArtifactsTriples = context.storage["existing-artifacts-triples"] as? [String] ?? []
                for target in Constants.buildTargets {
                    if existingArtifactsTriples.contains(target.triple) {
                        print("Skipping \(target.triple) as artifacts already exist")
                        continue
                    }
                    let (swiftBuild, swiftClean, strip, zip) = {
                        let buildFlags = ["--disable-sandbox", "--configuration", "release", "--triple", target.triple]
                        if target.os == .linux {
                            let platform = target.arch == .arm ? "linux/arm64" : "linux/amd64"
                            let dockerExec = "docker run --rm --volume \(context.projectRoot):/workdir --workdir /workdir --platform \(platform) swift:\(Constants.swiftVersion)"
                            let buildFlags = (buildFlags + ["--static-swift-stdlib"]).joined(separator: " ")
                            return (
                                "\(dockerExec) swift build \(buildFlags)",
                                "\(dockerExec) swift package clean",
                                "\(dockerExec) strip -s",
                                "zip -j"
                            )
                        } else {
                            let buildFlags = buildFlags.joined(separator: " ")
                            return (
                            "swift build \(buildFlags)",
                            "swift package clean",
                            "strip -rSTx",
                            "zip -j"
                            )
                        }
                    }()

                    try runAndPrint(bash: swiftClean)
                    try runAndPrint(bash: swiftBuild)

                    let binPath: String = run(bash: "\(swiftBuild) --show-bin-path").stdout
                    if binPath.isEmpty {
                        throw NSError(domain: "Fail to get bin path", code: -999)
                    }
                    let executablePath = binPath + "/\(Constants.executableName)"

                    try runAndPrint(bash: "\(strip) \(executablePath)")

                    let executableArchivePath = executableArchivePath(triple: target.triple, version: version)
                    try runAndPrint(bash: "\(zip) \(executableArchivePath) \(executablePath.replacingOccurrences(of: "/workdir", with: context.projectRoot))")
                }

                print("Release artifacts built successfully at '\(Constants.buildArtifactsDirectory)'")
            }
        )
    }

    static var cleanReleaseArtifacts: Command {
        Command(
            description: "Clean release artifacts",
            run: { _ in
                try? runAndPrint("rm", "-rf", Constants.buildArtifactsDirectory)
            }
        )
    }

    private static func executableArchivePath(triple: String, version: String) -> String {
        "\(Constants.buildArtifactsDirectory)/\(Constants.executableName)-\(version)-\(triple).zip"
    }
}
